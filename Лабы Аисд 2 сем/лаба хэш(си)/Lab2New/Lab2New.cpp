#include <iostream>
#include "Termin.h"

using namespace std;

void printReference()
{
    cout << "Справочник команд\n";
    cout << "\t1 - Добавить термин/подтермин\n" <<
        "\t2 - Добавить страницу к термину/подтермину\n" <<
        "\t3 - Удалить страницу термина/подтермина\n" <<
        "\t4 - Удалить термин/подтермин\n" <<
        "\t5 - Изменить термин\n" <<
        "\t6 - Изменить страницу\n" <<
        "\t7 - Поиск термина/подтермина\n" <<
        "\t8 - Вывести указатель отсортированный по алфавиту\n" <<
        "\t9 - Вывести указатель отсортированный по страницам\n" <<
        "\t10 - Выход\n";
    cout << "Введите команду: ";
}

int main()
{
    setlocale(LC_ALL, "Russian");
    Termin objectPointer;
    //objectPointer.addSubTermin(Termin("a", { 12, 2 }));
    //objectPointer.addSubTermin(Termin("b", { 14, 3 }));
    //objectPointer.printTerminsWithName("a");
    //objectPointer.printTerminsWithName("b");

    // Переменная для выхода из цикла(выход когда 10 нажали)
    bool isExit{ false };
    int option, subOption;
    // Основной цикл выполнения программы
    while (!isExit)
    {
        cout << "==========================================================\n";
        // Вывод всех терминов и подтерминов
        objectPointer.printSubjectPointer();
        cout << "==========================================================\n\n";
        // Вывод справочных команд
        printReference();
        // Выбираем команду(ввод)
        cin >> option;
        // Переход на след строку
        cout << endl;
        int page, newPage;
        string input;
        string newName;
        vector<Termin*> termins;
        vector<int> pagesNums;
        string pagesNumsStr;
        // В зависимости от выбранного введенного варианта
        switch (option)
        {
        case 1:
            cout << "Введите имя родительского термина/подтермина для добавления к нему в подтермина( / - основная ветвь ): ";
            // Название введенного термина или подтермина
            cin >> input;
            // Поиск есть ли такой родительский термин(обходит все ветки)
            objectPointer.findTermins(input, termins);
            if (termins.size() == 0)
                cout << "Такой родительский термин/подтермин не найден!\n";
            else
            {
                cout << "\nВведите имя добавляемого термина/подтермина: ";
                cin >> newName;
                cout << "\nВведите через пробел номера страниц термина/подтермина: ";
                // полная очистка буфера ввода
                cin.ignore(32767, '\n');
                // Чтение всей строки с пробелами
                getline(cin, pagesNumsStr);
                // Разбиение строки pageNumsStr на цифры страниц
                for (int i = 0; i < pagesNumsStr.size(); ++i)
                {
                    string pageNum = "";
                    while (pagesNumsStr[i] != ' ' && i < pagesNumsStr.size())
                    {
                        pageNum += pagesNumsStr[i];
                        ++i;
                    }
                    // Добавление страниц в вектор страниц объекта(термина)
                    pagesNums.push_back(stoi(pageNum));
                }
                // переход на след строку
                cout << '\n';
                // Вектор терминов, с совпадающими именами
                if (termins.size() > 1)
                {
                    
                    cout << "================================================\n";
                    for (int i = 0; i < termins.size(); ++i)
                    {   
                        cout << i + 1 << ")";
                        // вывод всех терминов/подтерминов с совпадающими именами для выбора, к чему добавить термин
                        objectPointer.printTerminAndSubTermins(termins[i]);
                        cout << '\n';
                    }
                    cout << "================================================\n";
                    cout << "Имеются следующие варианты терминов/подтерминов, выберите номер: ";
                    // Ввод опции, к какому термину добавить вводимый термин
                    cin >> subOption;
                    if (termins[subOption - 1]->addSubTermin(Termin(newName, pagesNums)))
                        cout << "Термин/подтермин успешно добавлен!\n";
                    else
                        cout << "Термин не был добавлен так как родительский термин носит то же имя, или среди подтерминов уже присутсутвует данное имя!\n";
                }
                else
                {
                    if (termins[0]->addSubTermin(Termin(newName, pagesNums)))
                        cout << "Термин/подтермин успешно добавлен!\n";
                    else
                        cout << "Термин не был добавлен, так как родительский термин носит то же имя \n или среди подтерминов уже присутсутвует данное имя!\n";
                }
            }
            break;
        case 2:

            cout << "Введите имя термина/подтермина, к которому хотите добавить страницу: ";
            // Вводим имя термина, в котором добавим страницу
            cin >> input;
            cout << "Введите страницу, которую хотите добавить: ";
            cin >> page;
            // После след строчки у нас в терминс появляются термины с введенным именем
            objectPointer.findTermins(input, termins);
            if (termins.size() == 0)
                cout << "Такой термин/подтермин не найден!\n";
            else
                // Если термин не один, то выбирать нужно из нескольких терминов с одинаковым именем
                if (termins.size() > 1)
                {
                    cout << "================================================\n";
                    for (int i = 0; i < termins.size(); ++i)
                    {
                        // Вывод всех терминов с одинаковыми именами, к которым может быть добавлена страница
                        cout << i + 1 << ")";
                        objectPointer.printTerminAndSubTermins(termins[i]);
                        cout << '\n';
                    }
                    cout << "================================================\n";
                    cout << "Имеются следующие варианты терминов/подтерминов, выберите номер: ";
                    // Выбираем номер термина, к которому добавить
                    cin >> subOption;
                    // Если метод addPage выдает тру для данного элемента в termins, то добавляем страницу
                    if (termins[subOption - 1]->addPage(page))
                        cout << "Страница успешна добавлена к термину/подтермину!\n";
                    else
                        cout << "Страница не была добавлена, так как уже содержится в термине/подтермине!\n";
                }
                else
                {
                    // Добавление страницы в единственный элемент
                    if (termins[0]->addPage(page))
                        cout << "Страница успешна добавлена к термину/подтермину!\n";
                    else
                        cout << "Страница не была добавлена, так как уже содержится в термине/подтермине!\n";
                }
            break;

        case 3:
            cout << "Введите имя термина/подтермина, страницу которого хотите удалить: ";
            cin >> input;
            cout << "Введите страницу, которую хотите удалить: ";
            cin >> page;
            // Ищем все термины с опр. именем и помещаем их в termins
            objectPointer.findTermins(input, termins);
            if (termins.size() == 0)
                cout << "Такой термин/подтермин не найден!\n";
            else
                // Если размер termins не равен 0, то есть термины с введенным именем
                if (termins.size() > 1)
                {
                    cout << "================================================\n";
                    // Выводим все подходящие термины с одинаковыми именами
                    for (int i = 0; i < termins.size(); ++i)
                    {
                        cout << i + 1 << ")";
                        objectPointer.printTerminAndSubTermins(termins[i]);
                        cout << '\n';
                    }
                    cout << "================================================\n";
                    cout << "Имеются следующие варианты терминов/подтерминов, выберите номер: ";
                    // Вводим номер выбранного термина
                    cin >> subOption;
                    // Если метод возвращает тру(по опр. причинам) то мы можем удалить страницу
                    if (termins[subOption - 1]->deletePage(page))
                        cout << "Страница успешна удалена!\n";
                    else
                        cout << "Страница не была удалена, т.к. ее не существовало или она была единственной!\n";
                }
                else
                {
                    // Если у нас есть один термин с таким именем, то сразу пытаемся удалить его
                    if (termins[0]->deletePage(page))
                        cout << "Страница успешна удалена!\n";
                    else
                        cout << "Страница не была удалена, т.к. ее не существовало или она была удинственной!\n";
                }
            break;
        
        case 4:
            cout << "Введите имя термина/подтермина, который вы желаете удалить: ";
            cin >> input;
            // Ищем все термины с именами, которые подходят под удаляемый элемент
            objectPointer.findParentsWithSubTerminName(input, termins);
            if (termins.size() == 0)
                cout << "Такой термин/подтермин не найден!\n";
            else
                // Если найдено 2 или более терминов с таким названием
                if (termins.size() > 1)
                {
                    cout << "================================================\n";
                    // Выводим все подходящие термины с одинаковыми именами
                    for (int i = 0; i < termins.size(); ++i)
                    {
                        cout << i + 1 << ")";
                        objectPointer.printTerminAndSubTermins(termins[i]);
                        cout << '\n';
                    }
                    cout << "================================================\n";
                    cout << "Имеются следующие варианты терминов/подтерминов, выберите номер: ";
                    // Вводим номер выбранного термина
                    cin >> subOption;
                    // Если метод возвращает true(т, е термин удален, по опр. причинам), то мы можем удалить
                    if (termins[subOption - 1]->deleteSubTermin(input))
                        cout << "Термин/подтермин успешно удален!\n";
                    else
                        cout << "В данном термине/подтермине нет подтермина с таким названием!\n";
                }
                else
                {
                    // Если был найден один термин(который находится в termins), то мы проводим удаление только с ним
                    if (termins[0]->deleteSubTermin(input))
                        cout << "Термин/подтермин успешно удален!\n";
                    else
                        cout << "В данном термине/подтермине нет подтермина с таким названием!\n";
                }
            break;

        case 5:
            cout << "Введите имя термина/подтермина, который вы желаете редактировать: ";
            cin >> input;
            cout << "Введите новое имя для термина/подтермина: ";
            cin >> newName;
            // Ищем термин с именем, которое было введено
            objectPointer.findTermins(input, termins);
            // Если размер вектора 0, но не было найдено таковых
            if (termins.size() == 0)
                cout << "Такой термин/подтермин не найден!\n";
            else
                // Если было найдено больше одного таких имен терминов
                if (termins.size() > 1)
                {
                    cout << "================================================\n";
                    // Выводим весь список терминов, которые подошли
                    for (int i = 0; i < termins.size(); ++i)
                    {
                        cout << i + 1 << ")";
                        objectPointer.printTerminAndSubTermins(termins[i]);
                        cout << '\n';
                    }
                    cout << "================================================\n";
                    cout << "Имеются следующие варианты терминов/подтерминов, выберите номер: ";
                    //Вводим номер термина, который редактируем
                    cin >> subOption;
                    // Вызываем метод объекта, которй меняет имя
                    termins[subOption - 1]->setName(newName);
                    cout << "Имя термина/подтермина успешно изменено!\n";
                }
                else
                {
                    // Так же вызываем метод объекта, который меняет имя, если термин с таким именем один
                    termins[0]->setName(newName);
                    cout << "Имя термина/подтермина успешно изменено!\n";
                }
            break;
        case 6:
            // Редактирование номера термина
            cout << "Введите имя термина/подтермина, который вы желаете редактировать: ";
            cin >> input;
            cout << "Введите номер страницы, который желаете редактировать: ";
            cin >> page;
            cout << "Введите новый номер для страницы: ";
            cin >> newPage;
            // Ищем все термины, удовлетворяющие введенному названию
            objectPointer.findTermins(input, termins);
            // Если не найден ни один термен
            if (termins.size() == 0)
                cout << "Такой термин/подтермин не найден!\n";
            else
                if (termins.size() > 1)
                {
                    // Если терминов больше одного
                    cout << "================================================\n";
                    for (int i = 0; i < termins.size(); ++i)
                    {
                        // Выводим весь список терминов, которые подошли
                        cout << i + 1 << ")";
                        objectPointer.printTerminAndSubTermins(termins[i]);
                        cout << '\n';
                    }
                    cout << "================================================\n";
                    cout << "Имеются следующие варианты терминов/подтерминов, выберите номер: ";
                    cin >> subOption;
                    // Выбираем номер термина, у которого нужно исправить номер и вызываем метод
                    if (termins[subOption - 1]->replacePageNum(page, newPage))
                        cout << "Номер страницы успешно изменен!\n";
                    else
                        cout << "Номер страницы не изменен, т.к. старая страница отсутствует или новая уже присутсутвует!э\n";
                }
                else
                {
                    // Если такой термин один, то сразу вызываем метод
                    if (termins[0]->replacePageNum(page, newPage))
                        cout << "Номер страницы успешно изменен!\n";
                    else
                        cout << "Номер страницы не изменен, т.к. старая страница отсутствует или новая уже присутсутвует!э\n";
                }
            break;
        case 7:
            cout << "Введите имя термина/подтермина, который вы желаете найти: ";
            cin >> input;
            // Ищем все термины с введенным именем
            objectPointer.findTermins(input, termins);
            // Если не было найдено вообще терминов с таким именем
            if (termins.size() == 0)
                cout << "Такой термин/подтермин не найден!\n";
            else
            {
                cout << "=====================================================\n";
                cout << "По вашему запросу найдены следующие результаты:\n";
                for (int i = 0; i < termins.size(); ++i)
                {
                    // Вывод всех терминов с введенным именем 
                    cout << i + 1 << ")";
                    objectPointer.printTerminAndSubTermins(termins[i]);
                    cout << '\n';
                }
                cout << "=====================================================\n";
            }
            break;
        case 8:
            objectPointer.sortByAlphabet();
            break;
        case 9:
            objectPointer.sortByPages();
            break;
        default:
            isExit = true;
            break;
        }

    }
}
